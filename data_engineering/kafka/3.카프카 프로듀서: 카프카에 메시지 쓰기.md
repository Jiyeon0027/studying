# Chapter3. 카프카 프로듀서: 카프카에 메시지 쓰기

## 3.1 프로듀서 개요

- 요구조건이 다양한 카프카 프로듀싱
  - 메시지 유실의 허용여부
  - 중복 허용 여부
  - 반드시 지켜야할 지연/ 처리율

![카프카프로듀서 요소 개괄](https://velog.velcdn.com/images%2Ffj2008%2Fpost%2Fa077c9ad-e0e2-4679-9755-2c2c46176b9d%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-02-06%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%2011.39.45.png)

1. `ProducerRecord` 객체를 생성
   - `토픽`과 `value` 지정은 필수
2. 네트워크 상 전송될 수 있도록 `직렬화`하여 바이트 배열로 변환
3. 파티션을 명시적 지정하지 않았으면 데이터를 파티셔너에세 보냄
4. 파티션이 결정되면 같은 토픽 파티션에 전송될 레코드들을 모은 `레코드 배치`에 추가
5. 별도의 스레드가 레코드 배치를 카프카 브로커에 전송
6. - 성공적 전송 : RecordMetadata 객체를 리턴
   - 실패 : 에러 리턴 후 재전송

## 3.2 카프카 프로듀서

- `bootstrap.servers`

  - 카프카 클러스터와 첫 연결을 하기 위해 프로듀서가 사용할 브로커의 host:port 목록을 의미
  - 브로커가 하나 작동 정지해도 돌아가게 최소 2개이상 지정

- `key.serializer`

  - 카프카에 쓸 레코드의 키 값을 직렬화 하기 위한 시리얼라이저 클래스의 이름
  - 매개변수화된 타입을 사용할 수 있도록 함
  - `ByteArraySerializer`
  - `StringSerializer`
  - `IntSerializer`

- `value.serializer`
  - `key.serializer`와 비슷하게 설정하면 됨

### 카프카 메시지 전송방식

- 파이어 앤 포겟 Fire and Forget

  - 메시지를 서버에 전송만 하고 성공 혹은 실패 여부에는 신경쓰지 않음.

- 동기적 전송 Synchronous send

  - 카프카 프로듀서는 언제나 비동기적으로 작동하고 send함수는 Future객체를 반환
  - 하지만 다음메시지 보내기전에 get()으로 실제 성공여부를 확인해야함

- 비동기적 전송 Asynchronous send
  - 기본적으로 프로듀서는 항상 비동기적으로 작동
  - 응답을 받는 시점에 콜백 메서드를 자동으로 호출

## 3.3 카프카로 메시지 전달하기

```java
ProducerRecord<String, String> record = new ProducerRecord<>("topic", "key", "value");
try {
    producer.send(record).get();
} catch (Exception e) {
    e.printStackTrace();
}
```

1. `ProducerRecord` 생성
2. `send` 메서드를 이용해 브로커에 전달
3. 오류시 `tryCatch`문에서 확인
   - `SerializationException` : 직렬화 오류
   - `TimeoutException` : 버퍼가 가득찼을 때
   - `InterruptException` : 작업을 수행하는 스레드에 인터럽트가 걸리는 경우

### 동기적으로 메시지 전송하기

동기적으로 메시지를 전송하는 방법은 간단하지만, 카프카 브로커가 쓰기 요청(produce request)에 에러를 내놓거나 재전송 횟수가 소진되었을 때 발생되는 예외를 받아서 처리할 수 있어야 함.

**주요한 균형점 : 성능 (performance)**

- 동기적으로 메시지를 전송하는 경우에는 결국 전송요청 스레드는 기다려야함으로 성능이 낮아짐

```java
try {
  producer.send(record).get() //Fure.get() 메서드의 동기처리
} catch (e: Exception) {
	e.printStacktrace()
}
```

- Kafka Producer 의 에러
  - 재시도 가능한 에러 : 브로커가 파티션 리더 아닌경우 ...
  - 재시도 불가능한 에러 : 메시지 크기가 큰 경우 ...

### 비동기적으로 메시지 전송하기

응답을 기다리지 않으면서도 에러를 처리하기 위해 콜백을 지정함

```java
producer.send(record) { metadata, exception ->
      if (exception != null) {
          e.printSTackTrace() //에러 콜백
      }
  }
```

## 3.4 프로듀서 설정하기

메모리 사용량, 성능 , 신뢰성에 영향을 미치는 값들 위주로 확인

- `client.id`

  - 프로듀서가 보내온 메시지를 서로 구분하기 위해 이 값을 사용
  - 클라이언트별로 사용량을 할당할 때도 사용

- `acks`

  - 이 매개변수는 프로듀서가 임의의 쓰기 작업이 성공했다고 판별하기 위해 얼마나 많은 파티션 레플리카가 해당 레코드를 받아야 하는 지 결정
  - `akcs = 0` : 메시지 전달을 보장하지 않으며 한번만 전달
  - `acks = 1` : 리더 레플리카가 메시지를 받으면 브로커로부터 성공했다는 응답을 받음
  - 리더가 크래시 난 경우에 리더 선출을 하지만 유실 가능성 있음
  - `acks = all` : 모든 인-싱크 레플리카에 전달된 뒤에 브로커로부터 성공했다는 응답을 받음
  - default로 3.0에서 설정됨

#### 메시지 전달 시간

send()를 호출했을뎨 성공 혹은 실패할때 까지 얼마나 시간이 걸리는가

- send()에 대한 비동기 호출이 이뤄진 시각부터 결과를 리턴할 때까지 걸리는 시간 (이 시간동안 send()를 호출한 스레드는 블록)

- send()에 대한 비동기 호출이 성공적으로 리턴한 시각부터(성공했든 실패했든) 콜백이 호출될 때 까지 걸리는 시간

![메시지 전달시간을 작업별로 나눈 개념도](https://velog.velcdn.com/images/cksgodl/post/1bfd688f-b8f9-4b92-ad56-fe4d9087dc73/image.png)

- `max.block.ms`
  - 프로듀서가 얼마나 오랫동안 블록되는지를 결정
  - 프로듀서의 전송 버퍼가 가득차거나 메타데이터가 아직 사용 가능하지 않을 때
- `delivery.timeout.ms`
  - 레코드 전송 준비가 완료된 시점(send()가 무사히 리턴되고 레코드가 배치에 저장된 시점)부터 브로커의 응답을 받거나 전송을 포기하게 되는 시점까지의 제한시간을 결정
  - `delivery.timeout.ms >= linger.ms + request.timeout.ms`
  - 카프카가 재시도 하는 도중 넘어가 버리면 마지막 재시도 전의 에러에 해당하는 예외의 콜백 호출
- `request.timeout.ms`
  - 서버로부터 응답을 받기 위해 얼마나 기다릴지
- `retries, retry.backoff.ms`

  - retries : 에러를 발생시킬때 까지 메시지를 재전송하는 횟수
  - retry.backoff.ms : 재시도 사이의 매개변수 간격 조정
  - 이 둘의 매개변수를 조정하기 보다는 `delivery.timeout.ms` 로 조절하기로 권장

<br><br>

- `lingers.ms`
  - 배치를 전송하기 전까지 대기하는 시간
- `buffer.memory`
  - 프로듀서가 메시지를 전송하기 전 메시지를 대기시키는 버퍼의 크기를 결정
  - max.block.ms만큼 기다리고 버퍼가 안비워지면 에러가 발생
- `compression.type`
  - 압축 타입을 지정 : snappy, gzip, lz4 ...
- `batch.size`
  - 같은 파티션에 다수의 레코드가 전송될 경우 프로듀서는 이들을 배치 단위로 모아서 한꺼번에 전송
  - 각각의 배치에 사용될 메모리의 양을 결정 (byte 단위 임을 주의)
- `max.in.flight.requests.per.connection`

  - 프로듀서가 서버로부터 응답을 받지 못한 상태에서 전송할 수 있는 최대 메시지 수를 결정

- `max.request.size`
  - 프로듀서가 한번에 전송하는 쓰기 요청의 크기를 결정
  - 브로커에도 메시지의 최대 사이즈 설정 `message.max.bytes`가 있음으로 이를 맞춰야 함.
- `receive.buffer.bytes, send.buffer.bytes`
  - TCP 소켓 송수신 버퍼 크기
- `enable.idepotence`
  - 정확히 한 번 전송할 수 있는 기능을 제공 (Exactly Once)

## 3.5 시리얼라이저

주로 StringSerializer가 사용되며, ByteArraySerializer등 각각의 형태에 대한 시리얼라이저가 존재하며 시리얼라이저를 작성하는 방법을 설명

정수나 문자열이 아닌 객체의 경우 두가지 설정

1. 범용 직렬화 라이브러리 - 추천!
2. 커스텀 직렬화 로직 작성

#### 커스텀 시리얼라이저

- 여러 팀에서 호환성을 유지해야하는 상황에서 계속 변경을 해야하는 상황이 생김
- 이 때문에 범용라이브러리를 사용할 것을 권장

#### 아파치 에이브로를 사용해서 직렬화

- Avro : 언어 중립적인 데이터 직렬화 형식
- 적합한 이유 : 메시지를 쓰는 애플리케이션이 새로운 스키마로 전환하더라고 기존 스키마와 호환성을 유지하는 한 데이터를 읽는 애플리케이션은 일케의 변경이나 업데이트 없이 계속해서 메시지를 처리할 수 있음

#### 카프카에서 에이브로 레코드를 사용하기

![에이브로 레코드의 직렬화와 역직렬화 처리 흐름](https://github.com/user-attachments/assets/e0e666c3-8d4d-4448-9c31-18d715a71cea)

- 스키마 레지스트리
  - 카프카에 데이터를 쓰기 위해 사용되는 모든 스키마를 저장
  - 레코드에 사용된 스키마의 고유 식별자만 심어주기
- 시리얼라이저 : 모든 작업(스키마를 레지스트리에 저장하고 필요할 때 가져오는)이 주어진 객체를 직렬화
- 디시리얼라이저 : 직렬화된 데이터를 객체로 복원

## 3.6 파티션

- ProduceRecord객체는 토픽, 키, 밸류의 값을 포함
- 키의 기본값이 null인 경우에 대해서 랜덤으로 RoundRobin 알고리즘이 적용되여 파티션중 하나에 저장

- 파티셔너는 접착성 처리를 지원

  - 접착성 처리가 없을 경우, 키값이 null인 메시지들은 파티션에 라운드 로빈으로 각각 배치
  - 접착성 처리가 있을 경우, 키 값이 null인 메시지들은 일단 키 값이 있는 메시지 뒤에 따라붙은 다음에야 라운드 로빈 방식으로 배치
  - 메시지의 배치 수 만큼 키가 null인 메시지를 키가 있는 메시지 뒤에 붙임
  - 균등한 분포를 가지도록 지원

- 커스텀 파티셔너
  - 파티셔너 함수를 만들어 특정 값이 포함된 경우 파티션 번호를 결정할 수 있음

## 3.7 헤더

- key/value 값을 건드리지 않고 추가 메타데이터를 심을때 사용
- 그 데이터 만으로 메시ㅣ지를 라우팅하거나 출처를 추적 (자동 암호화)

## 3.8 인터셉터

- 카프카의 클라이언트 코드를 고치지 않으면서 그 작동을 변경해야 하는 경우
- 두 메서드를 정의

```java
//프로듀서가 레코드를 브로커로 보냊기 전 , 직렬화 되기 직전 호출
ProducerRecord<K, V> onSend(ProducerRecord<K, V> record)\
//카프카 브로커가 보낸 응답을 클라이언트가 받았을때 호출 - 읽기만 가능
ProducerRecord<K, V> onAcknowledgemnt(ProducerRecord<K, V> record)
```

## 3.9 쿼터, 스로틀링

카프카 브로커의 한도(쿼터) 지정

1. 쓰기 쿼터 produce quota - 초당 바이트 수 단위로 제한
2. 읽기 쿼터 consume quota - 초당 바이트 수 단위로 제한
3. 요청 쿼터 request quota - 요청 처리시간 비율 단위로 제한

- 사용자에 대해 설정된 쿼터는 보안기능과 클라이언트 인증 기능이 활성화되어 있는 클라이언트에 대해서만 작동
- 만약 쿼터 값을 제한하고 클라이언트가 할당량을 다 채웠을 경우, 브로커는 클라이언트의 요청에 대해 스로틀링throttling을 시작하여 할당량을 초과하지 않도록 한다

## 3.10 요약

- 에러 핸들링/ 동기적 전송/ 비동기적 전송
- 프로듀서의 설정
- 직렬화 코드
- 파티셔너, 헤더, 인터셉터, 쿼터, 스로틀링 ...
