# Chapter 1. 카프카 시작하기

## 1.1 발행/구독 메시지 전달

- 발생/구독 메시지 전달 패턴 (pub/sub)

  - 직접 전달하지 않음
  - 발행자는 메시지를 어떤 형태로든 분류해서 보냄
  - 수신자는 분류된 메시지를 구독
  - 그 사이의 브로커 (broker)

- 초기의 발행/구독 시스템

  - 가운데에 간단한 메시지 큐나 프로세스 간 통신 채널을 놓는 것
  - 애플리케이션 지표를 지표서버로 연결하기
  - 구조가 복잡해지면서 점점 기술부채가 발생
  - 이를 해결하기 위한 구조
    ![지표발행 및 구독 시스템](https://velog.velcdn.com/images/cksgodl/post/7fd121c2-5213-41da-9eb4-fb30cdd83d44/image.png)

- 개별 메시지 큐 시스템

  - 하지만 발행/구독 시스템이 여러개 일 경우에도 중복적인 구조가 나타날 수 있음
  - 중앙 집중화된 시스템이 필요

## 1.2 카프카 입문

- 발행/구독 시스템

  - 분산 커밋 로그 & 분산 스트리밍 플랫폼

- 메시지와 배치
  - 카프카의 기본 단위 : 메시지
  - 키 (메타데이터 포함) : 파티션을 결정하기 위해서 사용 - 해시값을 생성후 파티션 저장
  - 메시지를 배치 단위로 저장 (지연 latency - 처리량throughput 사이의 트레이드 오프)
- 스키마
  - JSON, XML, Avro(직렬화 형식을 제공) ...
  - 일관전 데이터 형식이 중요
- 토픽과 파티션

  - 메시지를 토픽 다위로 분류하고 토픽은 다시 여러개의 파티션으로 분류됨
  - 각 파티션이 다른 서버에 저장될 수 있어 수평적 확장 가능
  - 각 파티션은 복제 가능하여 장애가 발생해도 문제발생 X
  - 스트림 : 한 토픽에 저장된 데이터

- 프로듀서와 컨슈머

  - 프로듀서 (발행자publisher, 작성장 writer)
  - 메시지 작성
    - 파티션을 고루게 나누어서
    - 특정 파티션에 대응(키와 해시값) - 파티셔너 이용
      <br><br>
  - 컨슈머 (구독자 subsrciber , 독자 reader)
  - 메시지의 offset을 기록함으로서 메시지를 어디까지 읽었는지 확인
  - 컨슈머 그룹의 일원으로 작동
    - 컨슈머 그룹 : 각 파티션이 하나의 컨슈머에 의해서만 읽히도록 하고 처리
    - 컨슈머 파티션 소유권

- 브로커와 클러스터

  - 브로커 : 카프카 서버
  - 카프카 브로커는 클러스터 역할의 일부로 컨트롤러 역할을 하게됨
  - 컨트롤러 : 파티션 리더를 결정, 팔로워라고 부름
  - 메시지를 지속성있게 보관하는 보존 기능
  - 핵심 기능
    - 메시지를 지속성 있게 보관하는 보존 기능
    - 로그 압착 기능을 설정가능

- 다중 클러스터
  - 장점
    - 데이터 유형별 분린
    - 보안 요구사항을 충족시키기 위한 격리
    - 재해 복구를 대비한 다중 데이터 센터
  - 다중 클러스터 사이에서가 아닌 하나의 클러스터 안에서만 작동하도록 구성된 카프카
  - 미러 메이커 : 데이터를 다른 클러스터로 복제

## 1.3 왜 카프카인가?

- 다중 프로듀서
- 다중 컨슈머
  - 많은 컨슈머가 상호 간섭없이 어떠한 메시지 스트림도 읽을 수 있음
  - 큐 시스템과의 차이
- 디스크 기반 보존
  - 지속성있게 보관
  - 옵션을 토픽별로 설정해 보유 규칙을 설정 가능
- 확장성
  - 브로커의 갯수를 조절해가며 가용성에 영향을 주지 않고 이동 가능
- 고성능
  - 매우 큰 메시지 스트림
- 플랫폼 기능
  - 유연성을 갖춘 api 와 라이브러리 형태로 사용 가능
  - 카프카 스트림즈( 스트림 처리 어플리케이션 사용 )

## 1.4 데이터 생태계

- 이용사례
  - 사용자 활동 추적
  - 메시지 교환
  - 로그 및 지표 수집
  - 커밋 로그
  - 스트림 처리

## 1.5 카프카의 기원

- 링크드인이 직면한 문제

  - 모니터링 시스템과 사용자 활동 추적을 한 서비스로 이용하고자 함 -수평확장

- 카프카의 탄생

  - 푸시-풀 모델
  - 다수의 컨슈머가 사용가능하게 데이터를 영속적 저장
  - 높은 메시지 처리량
  - 수평 확장

- 오픈 소스 출시
- 상업적 제품 출시
