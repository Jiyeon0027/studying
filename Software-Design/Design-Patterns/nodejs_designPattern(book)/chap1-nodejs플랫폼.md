## 1. Node.js 철학

### 경량 코어

- Node.js 코어의 바깥 부분에 유저랜드/유저스페이스라 불리는 사용자 전용 모듈 생태계 구성하여, 코어를 최소한의 기능으로 관리
- 커널 공간이 아닌 사용자 메모리 공간에서 실행

### 경량모듈

- Node.js는 재사용 가능한 라이브러리를 만들기 위한 기본적인 수단으로 Module 개념을 이용
- 코드의 양과 범위 측면에서 작은 모듈로 디자인 하는것이 Node.js에서 통용되는 원칙
  - 작은것이 아름답다
  - 각 프로그램은 한 가지 역할만 잘 하도록 만들어라
- 패키지 관리자(npm, yarn) 의 도움을 받아 각 패키지가 필요로하는 버전의 종속성 패키지를 가질 수 있다. 충돌 방지 뿐만아니라 많은 수의 작은 모듈을 가질수 있게 해준다.
- 작은 모듈의 장점
  1. 재사용성 증가, 이해 쉬움
  2. 테스트 및 유지보수 쉬움
  3. 사이즈가 작아 브라우저에서 사용하기 쉬움
- DRY(Don't Repeat Yourself) 원칙 : 반복하지 마라!

### 작은 외부 인터페이스

- node.js 모듈의 장점 : 작은 사이즈, 작은 범위, 최소한의 기능 노출
- 가장 일반적인 패턴 : 단일 진입점을 제공하기 위해 단 하나의 함수나 클래스를 노출하는것
- 확장 << 사용

### 간결함과 실용주의

- KISS(Keep it simple, stupid) 원칙 : 단순하게 설계하는 것이 가장 디자인에서 중요함. + 실용적인 접근 방식

## 2. Node.js 는 어떻게 작동하는가

### I/O는 느리다

- 램접근 속도 << 디스크와 네트워크에 접근하는 속도

### 블로킹 I/O

- 전통적인 블로킹 I/O 에서는 함수의 호출 작업이 완료될때 까지 스레드의 실행을 차단시킴
  → 블로킹 I/O를 사용하여 구현된 웹서버가 같은 스레드 내에서 여러 연결을 처리하지 못하는 것은 당연
- 이 동시 연결을 차리하기 위해 개별 스레드 또는 프로세스를 사용하는 것(다중 스레드)

![다중커넥션을 처리하기 위한 다중 스레드](https://prod-files-secure.s3.us-west-2.amazonaws.com/4cd83ffe-41f4-4681-8d1c-f4da55deddb1/617b0ad9-08ba-42a3-8ebc-849997474158/KakaoTalk_Photo_2024-11-25-23-58-15.jpeg)

위의 그림처럼 자주 스레드 블로킹을 통해 컨텍스트 전환일 이러나면 장기간 실행 스레드를 가지게 되며 메모리와 cpu 사이클 낭비

### 논 블로킹 I/O

- 데이터가 읽혀지거나 써지는 것을 기다리지 않고 항상 즉시 반환
- 이때 사용가능한 결과가 없는 경우 함수는 단순히 미리 정의된 상수를 반환
  → 사용가능한 데이터가 없음을 알림 (사용확인)
- 기본적인 패턴 : 실제 데이터가 반환될때 까지 루프 내에서 리소스를 적극적 폴링(polling)
  → 바쁜 대기(권한을 얻을때 까지 확인) : cpu 시간의 낭비 초래

### 이벤트 디멀티 플렉싱

- 이벤트 통지 인터페이스
- 멀티 플렉싱 : 여러 신호들을 하나로 합성해 제한된 수용범위 내에서 매개체를 통하여 쉽게 전달
- 디멀티 플렉싱 : 신호 다시 분할
- 동기 이벤트 디멀티 플렉서 : 여러 리소스를 관찰하여 읽기/쓰기 연산이 완료되었을 때 새로운 이벤트를 반환하는 방식. 새로운 이벤트가 반환되기 전까지 블로킹. 이러한 방식은 단일 쓰레드에서 여러 리소스의 I/O를 다룰 수 있다.

![이벤트 디멀티 플렉싱](https://prod-files-secure.s3.us-west-2.amazonaws.com/4cd83ffe-41f4-4681-8d1c-f4da55deddb1/7cb06e54-d63e-460c-b7fa-4081b0fbbedd/image.png)

→ 유휴시간을 최소화, 하나의 스레드에 동시 접근한 방식이 간단한 동시성 전략을 가지게 함

### 리액터(Reactor) 패턴

- 아이디어 : I/O 작업에 연관된 핸들러(콜백함수)를 가지고, 리소스가 준비되면 이벤트 루프에서 콜백함수를 호출하며 자원을 가져감

![리액터 패턴](https://prod-files-secure.s3.us-west-2.amazonaws.com/4cd83ffe-41f4-4681-8d1c-f4da55deddb1/83de3294-6fdb-4755-b8ff-74b8d102a0d3/image.png)

### Libuv, Node.js의 I/O 엔진

서로 다른 운영체제 간의 디멀티플렉서를 위한 자체 인터페이스의 불일치성은 이벤트 디멀티플렉서를 위해 보다 높은 레벨의 추상화를 필요로하게 되었다. 이러한 이유로 Node.js 코어 팀이 Node.js를 주요 운영체제에서 호환되게 해주며 서로 다른 리소스 유형의 논 블로킹 동작을 표준화하기 위해 libuv라고 불리는 C 라이브러리를 만들었다. Libuv는 Node.js의 하위 수준의 I/O 엔진을 대표하며 아마도 Node.js의 구성요소 중에서 가장 중요하다고 말할 수 있다.

Libuv는 기본 시스템 호출을 추상화하는 것 외에도 리액터 패턴을 구현하고 있으므로 이벤트 루프의 생성, 이벤트 큐의 관리, 비동기 I/O 작업의 실행 및 다른 유형의 작업을 큐에 담기 위한 API들을 제공한다.

### Node.js를 위한 구성

- 전체 플랫폼의 구축을 위한 3개의 구성
  - libuv와 다른 저수준 기능들을 랩핑하고 표출시키기 위한 바인딩 세트
  - V8, 크롬 브라우저를 위해 구글이 개발한 JavaScript 엔진으로 Node.js가 매우 빠르고 효율적인 이유 중 하나이기도 하다. V8은 혁신적인 설계와 속도 그리고 효율적인 메모리 관리로 높은 평가를 받고 있다.
  - 고수준 Node.js API를 구현하고 있는 코어 JavaScript 라이브러리

![Node.js 내부구성요소](https://prod-files-secure.s3.us-west-2.amazonaws.com/4cd83ffe-41f4-4681-8d1c-f4da55deddb1/e3fb76e8-1b22-4148-85c9-14d958278557/image.png)

## 3. Node.js 에서의 Javascript

- Node.js 에서는 운영체제에서 기본적으로 제공하는 서비스들에 접근 가능
- 브라우저 자바스크립트는 불가능

### 최신 javascript를 실행시켜라

- 가장 최신 버전의 v8 을 사용하면 대부분의 변환 없이 ECMA script 사양 특성들 대부분 사용 가능
- 라이브러리 개발시 LTS지원 버전 중 가장 오래된 것을 기준으로 삼고 package.json 에 엔진을 명시

### 모듈 시스템

- 기존의 nodejs 모듈 시스템 : commonJS → 내장 모듈 또는 장치의 파일시스템에 위치한 모듈로부터 임포트 하기 위해 require사용
- ES 모듈 문법 : Node.js 에서는 문법만 상속 받으며 브라우저와 달리 로컬 파일 시스템 모듈만 다룰 수 있음

### 운영체제 기능에 대한 모든 접근

- fs, net, dgram, … 과 같은 모듈로 운영체제에서의 주된 서비스를 바인딩 가능

### 네이티브 코드 실행

- C/C++로 만들어져 있거나 새로 만늘어진 컴포넌트를 사용할 수 있음 (네이티브 코드에 바인딩)
  → 사물인터넷, 로보틱스에서 인기를 끌고 있음
- Javascript VM 은 javascript 이외의 언어를 이해가능한 형식으로 컴파일 해주는 웹어셈블리 지원
